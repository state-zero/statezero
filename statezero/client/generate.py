"""
Code generation for the StateZero Python client.

Reads model schemas and action definitions from the Django runtime registry,
then writes out a standalone Python package that uses only the runtime
(copied from runtime_template.py) and httpx.
"""
import os
import shutil
from collections import defaultdict
from pathlib import Path

from statezero.adaptors.django.config import config, registry
from statezero.core.actions import action_registry


# ---------------------------------------------------------------------------
# Type mapping — schema FieldType/FieldFormat → Python type annotation string
# ---------------------------------------------------------------------------

_TYPE_MAP = {
    "integer": "int",
    "string": "str",
    "boolean": "bool",
    "number": "float",
    "array": "list",
    "object": "dict",
    "file": "str",
}

_FORMAT_MAP = {
    "date": "str",
    "date-time": "str",
    "time": "str",
    "decimal": "str",
    "json": "dict",
    "file-path": "str",
    "image-path": "str",
    "money": "str",
}


def _python_type(field_meta):
    """Return a Python type annotation string for a schema field."""
    fmt = field_meta.format
    if fmt and fmt in _FORMAT_MAP:
        return _FORMAT_MAP[fmt]
    return _TYPE_MAP.get(field_meta.type, "object")


def _fk_python_type(field_meta):
    """Return the Python type for a FK/O2O field based on its schema type.

    The schema type is determined by the related model's PK — it could be
    'integer', 'string' (UUID/CharField), etc.  We read from the schema
    rather than assuming int.
    """
    return _TYPE_MAP.get(field_meta.type, "object")


# ---------------------------------------------------------------------------
# Model code generation
# ---------------------------------------------------------------------------

def _generate_model_file(app_label, models_in_app):
    """Generate Python source for all models in one app.

    Args:
        app_label: Django app label
        models_in_app: list of (model_class, model_config, schema) tuples

    Returns:
        (source_code, list_of_class_names)
    """
    lines = ["# Auto-generated by StateZero. Do not edit.", "from .._runtime import Model", ""]

    class_names = []
    for model_class, model_config, schema in models_in_app:
        class_name = schema.class_name
        model_name = schema.model_name
        pk_field = schema.primary_key_field
        class_names.append(class_name)

        # Build _relations dict: {field_name: related_model_name}
        relations = {}
        for field_name, rel_info in schema.relationships.items():
            rel_type = rel_info.get("type", "")
            # Only FK and O2O resolve to a single instance via cache
            if rel_type in ("foreign-key", "one-to-one"):
                relations[field_name] = rel_info["model"]

        lines.append("")
        lines.append(f"class {class_name}(Model):")
        lines.append(f'    _model_name = "{model_name}"')
        lines.append(f'    _pk_field = "{pk_field}"')
        lines.append(f"    _relations = {relations!r}")

        # Add field annotations as comments for IDE discoverability
        for field_name, field_meta in schema.properties.items():
            fmt = field_meta.format
            if fmt in ("foreign-key", "one-to-one"):
                py_type = _fk_python_type(field_meta)
            elif fmt == "many-to-many":
                py_type = "list"
            else:
                py_type = _python_type(field_meta)
            if field_meta.nullable:
                py_type = f"{py_type} | None"
            lines.append(f"    # {field_name}: {py_type}")

        lines.append("")

    return "\n".join(lines) + "\n", class_names


# ---------------------------------------------------------------------------
# Action code generation
# ---------------------------------------------------------------------------

def _generate_action_file(app_label, actions_in_app):
    """Generate Python source for all actions in one app.

    Args:
        app_label: app grouping string
        actions_in_app: list of (action_name, action_def) tuples

    Returns:
        (source_code, list_of_function_names)
    """
    lines = [
        "# Auto-generated by StateZero. Do not edit.",
        "from .._runtime import _transport, _resolve_value",
        "",
    ]

    func_names = []
    for action_name, action_def in actions_in_app:
        func_name = action_name  # already snake_case from registry key
        func_names.append(func_name)

        serializer = action_def.get("serializer")
        params = []
        if serializer:
            # Introspect serializer fields for function signature
            try:
                serializer_instance = serializer()
                for fname, field_obj in serializer_instance.fields.items():
                    if field_obj.required:
                        params.append(fname)
                    else:
                        params.append(f"{fname}=None")
            except Exception:
                params.append("**kwargs")

        if not params:
            params_str = "**kwargs"
            body_build = "    data = kwargs"
        else:
            params_str = ", ".join(params)
            # Build data dict from named params
            param_names = [p.split("=")[0] for p in params]
            if params == ["**kwargs"]:
                body_build = "    data = kwargs"
            else:
                dict_items = ", ".join(f'"{n}": {n}' for n in param_names)
                body_build = f"    data = {{{dict_items}}}"
                body_build += "\n    data = {k: v for k, v in data.items() if v is not None}"

        docstring = action_def.get("docstring", "")
        if docstring:
            doc_lines = docstring.split("\n")
            doc_str = "\n    ".join(doc_lines)
            lines.append(f"def {func_name}({params_str}):")
            lines.append(f'    """{doc_str}"""')
        else:
            lines.append(f"def {func_name}({params_str}):")

        lines.append(body_build)
        lines.append("    data = {k: _resolve_value(v) for k, v in data.items()}")
        lines.append(f'    return _transport.post_action("{action_name}", data)')
        lines.append("")
        lines.append("")

    return "\n".join(lines) + "\n", func_names


# ---------------------------------------------------------------------------
# Package generation
# ---------------------------------------------------------------------------

def generate_client(output_dir):
    """Generate the complete client package.

    Args:
        output_dir: Path to the output directory (e.g. "./sz")
    """
    output = Path(output_dir)

    # Ensure config is initialized
    if not hasattr(config, 'schema_generator') or config.schema_generator is None:
        config.initialize()

    # Create directory structure
    models_dir = output / "models"
    actions_dir = output / "actions"
    models_dir.mkdir(parents=True, exist_ok=True)
    actions_dir.mkdir(parents=True, exist_ok=True)

    # Copy runtime template as _runtime.py
    runtime_src = Path(__file__).parent / "runtime_template.py"
    shutil.copy2(runtime_src, output / "_runtime.py")

    # ---- Generate model files ----
    # Group models by app label
    models_by_app = defaultdict(list)
    for model_class, model_config in registry._models_config.items():
        schema = config.schema_generator.generate_schema(
            model_class,
            global_schema_overrides=config.schema_overrides,
            additional_fields=model_config.additional_fields or [],
        )
        app_label = schema.model_name.split(".")[0]
        models_by_app[app_label].append((model_class, model_config, schema))

    all_model_imports = {}  # app_label -> [class_names]
    for app_label, models_in_app in models_by_app.items():
        source, class_names = _generate_model_file(app_label, models_in_app)
        (models_dir / f"{app_label}.py").write_text(source)
        all_model_imports[app_label] = class_names

    # models/__init__.py — re-export all
    init_lines = []
    for app_label, class_names in sorted(all_model_imports.items()):
        names = ", ".join(sorted(class_names))
        init_lines.append(f"from .{app_label} import {names}")
    (models_dir / "__init__.py").write_text("\n".join(init_lines) + "\n")

    # ---- Generate action files ----
    actions = action_registry.get_actions()
    actions_by_app = defaultdict(list)
    for action_name, action_def in actions.items():
        module = action_def.get("module", "")
        # Try to extract app from module path
        parts = module.split(".")
        app_label = parts[0] if parts else "general"
        actions_by_app[app_label].append((action_name, action_def))

    all_action_imports = {}
    for app_label, actions_in_app in actions_by_app.items():
        source, func_names = _generate_action_file(app_label, actions_in_app)
        (actions_dir / f"{app_label}.py").write_text(source)
        all_action_imports[app_label] = func_names

    # actions/__init__.py
    init_lines = []
    for app_label, func_names in sorted(all_action_imports.items()):
        names = ", ".join(sorted(func_names))
        init_lines.append(f"from .{app_label} import {names}")
    (actions_dir / "__init__.py").write_text("\n".join(init_lines) + "\n" if init_lines else "")

    # ---- Top-level __init__.py ----
    (output / "__init__.py").write_text(
        "from ._runtime import configure, Q, F, FileObject, StateZeroError, ValidationError, NotFound, PermissionDenied, MultipleObjectsReturned\n"
    )

    return output
